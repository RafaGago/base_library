#!/bin/bash -e

# A script to:
# -perform simple substitutions on files
# -generate multiple files from one.
#
# The sintax of a file is like this:
#
# /* AUTOGENERATE: include/bl/base/add_two_{MYTYPE}.h*/
#
# struct two_{MYTYPE} {
#   {MYTYPE} a;
#   {MYTYPE} b;
# };
#
# {MYTYPE} add_two_{MYTYPE} (two_{MYTYPE} const* two);
#
# /* AUTOGENERATE: src/bl/base/add_two_{MYTYPE}.c*/
#
# #include <include/bl/base/add_two_{MYTYPE}.h>
#
# {MYTYPE} add_two_{MYTYPE} (two_{MYTYPE} const* two)
# {
#   return two->a + two->b
# }
#
# Then you can run:
# autogenerator.sh -f <FILE> -r "MYPE=unsigned long"

SPACE_ENCODING="!!!!!"

function errcho() { echo "$@" 1>&2; }

function print_usage(){
  echo "$1 -f,--file FILE -r,--replacements CSV_KV_LIST... [--only-print-filenames]"
  echo "ex $1 -f FILE -r KEY1=val1,KEY2=val2 -r KEY1=val3,KEY2=val4"
}

CMDLINE="$0 $@"
PROJROOT=$(dirname "$(readlink -f "$0")")/..

while [[ $# -ge 1 ]]; do
  key="$1"
  case $key in
    --only-print-filenames)
    ONLY_PRINT=1
    ;;
    -f|--file)
    FILE="$2"
    shift #consume an argument
    ;;
    -r|--replacements)
    REPLACEMENTS=$REPLACEMENTS$(echo "$2" | sed "s| |$SPACE_ENCODING|g")" "
    shift #consume an argument
    ;;
    -h|--help)
    print_usage $0
    exit 0
    ;;
    *)
    errcho "invalid argument"
    print_usage $0
    exit 1
    ;;
  esac
  shift
done

if [[ ! -f $FILE ]]; then
  $PROJFILE="$PROJROOT/$FILE"
  #try with a file referenced to the project root
  if [[ ! -f $PROJFILE ]]; then
    errcho "file not found: \"$FILE\" or \"$PROJFILE\""
    exit 1
  fi
  FILE="$PROJFILE"
fi

if [[ -z $REPLACEMENTS ]]; then
  errcho "no replacements found"
  exit 1
fi


function write_file() {
  local SRC="$1"
  local DST=$(echo "$PROJROOT/$2" | sed 's| |_|g')
  local START="$3"
  local END="$4"

  if [[ ! -z $ONLY_PRINT ]]; then
    echo "$DST"
    return 0
  fi

  mkdir -p $(dirname "$DST")
  cat << EOF > $DST
/*
Autogenerated file by running:
$CMDLINE

Don't edit.
*/
EOF
  sed -n "${START},${END}p" $SRC >> $DST
}

function split_files() {
  local SPLITS=$(grep -n "AUTOGENERATE" $1 | sed 's|/\*\+||g' | sed 's|\*\+/||g')
  SPLITS=$(echo "$SPLITS" | sed 's| *AUTOGENERATE *\: *||g')
  SPLITS=$(echo "$SPLITS" | sed 's| *$||g')

  if [[ -z $SPLITS ]]; then
    errcho "In $1: No autogenerations specified."
    return 1
  fi

  local START=""
  local FILEPREV=""
  for SPLIT in $SPLITS; do
    if [[ "$SPLIT" == $'\r' ]]; then
      # empty line, skip
      continue
    fi
    local LINE=$(echo "$SPLIT" | cut -d : -f 1)
    local FILE=$(echo "$SPLIT" | cut -d : -f 2)
    if [[ -z "$FILE" ]] ; then
      errcho "In line $LINE of $1: No autogeneration file specified."
      return 1
    fi
    if [[ ! -z $START ]]; then
      write_file "$1" "$FILEPREV" "$START" $((LINE-1))
    fi
    START="$LINE"
    FILEPREV="$FILE"
  done
  #last chunk
  write_file "$1" "$FILEPREV" $START $(wc -l $1)
}

for KEYVALUES in $REPLACEMENTS; do
  TMP=$(mktemp)
  KEYVALUES=$(echo $KEYVALUES | sed 's|,| |g')
  SED_CMD=""
  for KEYVALUE in $KEYVALUES; do
    #Restore spaces
    KEYVALUE=$(echo "$KEYVALUE" | sed "s|$SPACE_ENCODING| |g")
    KEY=$(echo "$KEYVALUE" | cut -d = -f 1)
    VAL=$(echo "$KEYVALUE" | cut -d = -f 2)
    if [[ -z $KEY ]]; then
      errcho "no valid KEY in: $KEYVALUE"
      exit 1
    fi
    if [[ ! -z $SED_CMD ]]; then
      SED_CMD=$SED_CMD";"
    fi
    KEYUP=${KEY}_UPPER
    KEYLO=${KEY}_LOWER
    VALUP="$(echo "$VAL" | tr '[:lower:]' '[:upper:]')"
    VALLO="$(echo "$VAL" | tr '[:upper:]' '[:lower:]')"

    SED_CMD=$SED_CMD" s|\{$KEY\}|${VAL}|g"
    SED_CMD=$SED_CMD" ; s|\{$KEYUP\}|${VALUP}|g"
    SED_CMD=$SED_CMD" ; s|\{$KEYLO\}|${VALLO}|g"
  done
  cat $FILE | sed -r "$SED_CMD" > $TMP
  split_files $TMP
  rm $TMP
done


