#!/bin/bash -e

# A script to:
# -perform simple substitutions on files
# -generate multiple files from one.
#
# The sintax of a file is like this:
#
# /* AUTOGENERATE: include/bl/base/add_two_{MYTYPE}.h*/
#
# struct two_{MYTYPE} {
#   {MYTYPE} a;
#   {MYTYPE} b;
# };
#
# {MYTYPE} add_two_{MYTYPE} (two_{MYTYPE} const* two);
#
# /* AUTOGENERATE: src/bl/base/add_two_{MYTYPE}.c*/
#
# #include <include/bl/base/add_two_{MYTYPE}.h>
#
# {MYTYPE} add_two_{MYTYPE} (two_{MYTYPE} const* two)
# {
#   return two->a + two->b
# }
#
# Then you can run:
# autogenerator.sh -f <FILE> -r "MYPE=unsigned long"

SPACE_ENCODING="!!!!!"

function errcho() { echo "$@" 1>&2; }

function print_usage(){
  echo "$1 -f,--file FILE -r,--replacements CSV_KV_LIST..."
  echo "ex $1 -f FILE -r KEY1=val1,KEY2=val2 -r KEY1=val3,KEY2=val4"
}

while [[ $# -gt 1 ]]; do
  key="$1"

  case $key in
    -f|--file)
    FILE="$2"
    shift
    ;;
    -r|--replacements)
    REPLACEMENTS=$REPLACEMENTS$(echo "$2" | sed "s| |$SPACE_ENCODING|g")" "

    shift
    ;;
    -h|--help)
    print_usage $0
    exit 0
    ;;
    *)
    errcho "invalid argument"
    print_usage $0
    exit 1
    ;;
  esac
  shift
done

if [[ ! -f $FILE ]]; then
  errcho "file not found: $1"
  exit 1
fi

if [[ -z $REPLACEMENTS ]]; then
  errcho "no replacements found"
  exit 1
fi

PROJROOT=$(dirname "$(readlink -f "$0")")/..

function write_file() {
  local SRC="$1"
  local DST=$(echo "$PROJROOT/$2" | sed 's| |_|g')
  local START="$3"
  local END="$4"
  mkdir -p $(dirname "$DST")
  echo "/* Autogenerated file, don't edit */" > $DST
  sed -n "${START},${END}p" $SRC >> $DST
}

function split_files() {
  local SPLITS=$(grep -n "AUTOGENERATE:" $1)
  SPLITS=$(echo "$SPLITS" | sed 's|\([0-9]\+\)\:.*AUTOGENERATE: *\(.*\) *\*/ *|\1:\2|g')
  SPLITS=$(echo "$SPLITS" | sed 's|[ ]\+|_|g')
  SPLITS=$(echo "$SPLITS" | sed 's|^_||g')
  SPLITS=$(echo "$SPLITS" | sed 's|_$||g')
  if [[ -z $SPLITS ]]; then
    errcho "In $1: No autogenerations specified."
    return 1
  fi

  local START=""
  local FILEPREV=""
  for SPLIT in $SPLITS; do
    local LINE=$(echo "$SPLIT" | sed 's|\([0-9]\+\)\:.*|\1|g')
    local FILE=$(echo "$SPLIT" | sed 's|[0-9]\+\:\(.*\)|\1|g')
    if [[ -z "$FILE" ]] ; then
      errcho "In line $LINE of $1: No autogeneration file specified."
      return 1
    fi
    if [[ ! -z $START ]]; then
      write_file "$1" "$FILEPREV" "$START" $((LINE-1))
    fi
    START="$LINE"
    FILEPREV="$FILE"
  done
  #last chunk
  write_file "$1" "$FILEPREV" $START $(wc -l $1)
}

for KEYVALUES in $REPLACEMENTS; do
  TMP=$(mktemp)
  KEYVALUES=$(echo $KEYVALUES | sed 's|,| |g')
  SED_CMD=""
  for KEYVALUE in $KEYVALUES; do
    #Restore spaces
    KEYVALUE=$(echo $KEYVALUE | sed "s|$SPACE_ENCODING| |g")
    KEY=$(echo $KEYVALUE | sed 's|\([^=]*\)=[^=]*|\1|g')
    VAL=$(echo $KEYVALUE | sed 's|[^=]*=\([^=]*\)|\1|g')
    if [[ -z $KEY ]]; then
      errcho "no valid KEY in: $KEYVALUE"
      exit 1
    fi
    if [[ ! -z $SED_CMD ]]; then
      SED_CMD=$SED_CMD";"
    fi
    SED_CMD=$SED_CMD" s|\{$KEY\}|${VAL}|g"
  done
  cat $FILE | sed -r "$SED_CMD" > $TMP
  split_files $TMP
  rm $TMP
done

